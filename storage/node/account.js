/**
 * account.js
 */
"use strict";

const Roles = require('./roles');
const crypto = require('node:crypto');

module.exports = class Account {

  /**
   * account constructor
   * @param {*} userid
   */
  constructor(account = '') {
    this.clear();
    if (typeof account === 'string')
      this.userid = account;
    else
      this.copy(account);
  }

  clear() {
    // default properties for a new account
    this.userid = '';
    this.password = '';
    this.roles = [ Roles.Guest ];

    this.dateCreated = null;
    this.dateUpdated = null;
    this.lastLogin = null;

    // note, state is updated at runtime
    // state can be copied, but shouldn't be saved or serialized
    this.state = {
      isAuthenticated: false
    };

    this.profile = {
      userName: '', // Tname of this account, suitable for display.
      givenName: '', // first name of user.
      middleName: '', // middle name(s) of user.
      familyName: '', // last name of user.
      email: '', // user's contact email address.
      photoURL: '', // URL of an image.
      webURL: '', // URL of user's web site
      // external links
      links: [{
        name: '', // The provider with which the account authenticated (facebook, twitter, etc.).
        webURL: '', // A unique identifier for the account, as generated by the service provider.
      }]
    };

    this.settings = {
      homePage: '',
      theme: '',
      darkMode: false
    };
  }

  /**
   * Hash plain text passwords.
   *
   * @param pwd The string to be hashed.
   * @returns {*} A string containing the hash results.
   */
  static hashPwd(pwd) {
    let hash = crypto.createHash("sha1");
    hash.update(pwd, "utf8");
    return hash.digest("base64");
  }

  get isAuthenticated() {
    return this.state.isAuthenticated;
  }
  set isAuthenticated(value) {
    this.state.isAuthenticated = value;
  }

  /**
   * isAuthorized returns true if user has at least one of the requested role(s).
   * @param {*} role as a string or array of strings
   */
  isAuthorized(roles) {
    if (this.roles.includes(Roles.Super))
      return true;

    if (typeof roles === "string") {
      return roles === Roles.Public || this.roles.includes(roles);
    }
    else if (Array.isArray(roles)) {
      if (roles.includes(Roles.Public))
        return true;

      return roles.some(role => this.roles.includes(role));
    }
    return false;
  }

  // shallow copy of properties
  // excluding functions, undefined values
  copy(a2) {
    let a1 = this;

    Object.keys(a2).forEach(function (key) {
      let t = typeof a2[key];
      if (t !== "undefined" && t !== "function") {
        a1[key] = a2[key];
      }
    });
  }

  // shallow copy of account properties
  // excluding userid, password, roles, state, functions, undefined values
  update(a2) {
    let a1 = this;

    Object.keys(a2).forEach(function (key) {
      let t = typeof a2[key];

      if (key === 'userid' || key === 'password' || key === 'roles' || key === 'state') {
        //
      } else if (t !== "undefined" && t !== "function") {
        a1[key] = a2[key];
      }
    });
  }

  /**
   * Sanitized copy of account properties for sending to client apps.
   * Stripped of password, state, functions and undefined values.
   */
  sanitize() {
    let a1 = {};
    let a2 = this;

    Object.keys(this).forEach(function (key) {
      let t = typeof a2[key];

      if (key === 'password' || key === 'state') {
        // skip
      } else if (t !== "undefined" && t !== "function") {
        a1[key] = a2[key];
      }
    });

    return a1;
  }

  /**
   * Representation of construct for storage.
   * Any user-defined fields need to be stuffed into profile or settings.
   *
   * @param {*} pack
   */
  encode() {
    let construct = {
      userid: this.userid,
      password: this.password,
      roles: this.roles,
      dateCreated: this.dateCreated,
      dateUpdated: this.dateUpdated,
      lastLogin: this.lastLogin,
      profile: this.profile,
      settings: this.settings
    };
    return construct;
  }
}
